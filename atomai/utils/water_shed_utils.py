import cv2
import numpy as np
import matplotlib.pyplot as plt
from skimage import measure
import pandas as pd

def RGBtoGRAY(img):
    '''Turns the image from RGB to GRAY
    Args:
        img (np.ndarray): The image to be converted
    
    '''
    return img[:,:,0]


def make_borders(img: np.ndarray, border_size: int = 3,erode=True,dilate=True):
    '''
    Generates border for the image and converts [0,1] : [background, particle] to 
                                                [0,1,2] : [border, particle , background ]
    This is done so as to make it compatible with watershed segmentation, which requires uncertain regions 
    to be maked with 0
    
    Args:
        img (np.ndarray): The image to be 'bordered'
        border_size (int): border size
    
    '''
    if erode:
        erosion_kernel = np.ones((3,3))      ## Start by eroding edge pixels
        eroded_image = cv2.erode(img, erosion_kernel, iterations=1)
    else:
        eroded_image=img
    
    kernel_size = 2*border_size + 1 
    dilation_kernel = np.ones((kernel_size, kernel_size))   #Kernel to be used for dilation
    if dilate==True:
        dilated  = cv2.dilate(eroded_image, dilation_kernel, iterations = 1)
    else:
        dilated=eroded_image
    
    ## Replace the pixel values -> [0,1] : [background, particle] to [0,1,2] : [border, particle , background ]

    dilated = (1 - dilated)*2 
    original_with_border = np.where(eroded_image > 0, 1, dilated)
    
    return original_with_border


def watershed_segmentation(img_base:np.ndarray, img_mask: np.ndarray, border_size: int = 3):
    '''
    Does watershed  for the image and converts [0,1] : [background, particle] to 
                                                [0,1,2] : [border, particle , background ]
    This is done so as to make it compatible with watershed segmentation, which requires uncertain regions 
    to be maked with 0
    
    Args:
        img_base (np.ndarray): The base image
        img_mask (np.ndarray): The mask of the image to be 'watershed'. It contains 0: uncertain class
        border_size (int): border size
    
    '''
    sure_fig=np.where(img_mask==1,1,0).astype(np.uint8)
    #create markers
    '''
    Markers have shape of the image and are basically instantiated masks. 
    Then why watershed? 
    It helps us deal with uncertain boundaries of porosities.
    Thus we
    '''
    
    ret3, markers = cv2.connectedComponents(sure_fig)
    #need background to be non zero s0 add 10. It will be treated as a component
    markers = markers+10
    #sert uncertain regions to 0
    markers=np.where(img_mask==0,0,markers)
    
    #convert to RGB as watershed works with RGB
    if img_base.shape[-1]!=3:
        img_base=cv2.cvtColor(img_base, cv2.COLOR_GRAY2BGR)
    markers = cv2.watershed(img_base, markers)
    
    return markers



def plot_instantiated(markers:np.ndarray,force_borders=True):
    '''
    Plots instantiated regions with different colors and borders with black
    Args:
        markers(np.ndarray): Markers image generated by watershed segmentation
    
    '''
    # Generate random colors

    unique_markers=np.unique(markers)

    colors = np.random.randint(0, 255, size=(len(unique_markers) - 1, 3))


    # Create an output image
    output_image = np.zeros_like(cv2.cvtColor(markers.astype(np.uint8),cv2.COLOR_GRAY2BGR))

    # Color the segments and highlight boundaries
    for marker_idx in range(len(unique_markers)):
        marker=unique_markers[marker_idx]

        if marker == -1:# boundary
            #Highlight the boundary in black
            color=[0,0,0]
            # Create a mask for the current segment
            mask = markers == marker

            # Color the pixels based on the mask
            output_image[mask] = color

        elif marker == 10:
            color=[152,252,152]
            mask = markers == marker
            output_image[mask] = color

        else:
            color=colors[marker_idx-2]
            mask = markers == marker
            output_image[mask] = color

        if -1 not in unique_markers or force_borders==True:
            #Handles no boundaries
            # Find the contours of the mask
            contours, _ = cv2.findContours(mask.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            cv2.drawContours(output_image, contours, -1, (0, 0, 0), thickness=3)

    plt.imshow(output_image)



def region_properties(img_base:np.ndarray, markers:np.ndarray):
    '''
    Generates region properties for the image using markers generated by watershed
    
    Args:
        img_base (np.ndarray): The base image 
        markers (int): The maker corresponding to the base image generated by watershed
    
    '''
    props = measure.regionprops_table(markers, intensity_image=img_base, 
                                  properties=['area', 'perimeter', 'equivalent_diameter','major_axis_length',
                                              'minor_axis_length','eccentricity', 'orientation',  'solidity'])
    df = pd.DataFrame(props)
    return df[1:]



def marker_to_polygon(markers:np.ndarray,eps: int=0.01,  visualize:bool=True):
    '''
    Generates polygons using markers generated by watershed
    
    Args:
        markers (int): The maker corresponding to the base image generated by watershed
        eps (int): Controls the precision of the approximation. Smaller the better (must be >0)
        visualize (bool): Plots the polygons if True
    
    '''

    # Initialize an empty list to hold the polygon approximations
    polygons = []

    # Iterate through each unique marker value
    for marker in np.unique(markers):
        if marker == 10 or marker == -1:
            # Skip the background and watershed boundary markers
            continue

        # Create a binary mask for the current marker
        mask = np.zeros(markers.shape, dtype=np.uint8)
        mask[markers == marker] = 255

        # Find contours for marker
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # Approximate each contour to a polygon and add it to the list
        for contour in contours:
            # The epsilon parameter: controls the approximation accuracy
            epsilon = eps * cv2.arcLength(contour, True)
            polygon = cv2.approxPolyDP(contour, epsilon, True)
            polygons.append(polygon)

    # Optional: Visualize the result
    if visualize==True:
        output_image = cv2.cvtColor(markers.astype(np.uint8), cv2.COLOR_GRAY2BGR)
        for polygon in polygons:
            cv2.polylines(output_image, [polygon], True, (0, 255, 0), 2)
        plt.imshow(output_image)
        
    #return polygons 
    return polygons



def convert_preds_to_classes(preds):
    '''
    Use this function to convert the prediction probabilities to classes
    Args:
        preds (np.ndarray): prediction probabailities
    '''
    if preds.shape[-1]==1 or len(preds.shape)==2: #only 1 class
        return np.where(preds>=0.5,1,0)[:,:,0].astype(np.uint8) 
        
    return np.argmax(preds,axis=-1).astype(np.uint8) 

def pred_to_prop_masks(images_base, preds, is_bordered=False):
    
    '''
    This function produces final watershed markers, geometric property tables and polygons for each image in the array supplied.
    Args:
        images_base(np.ndarray): Input set of images 
        preds(np.ndarray): predictions of the AtomAI Segmentor model
        is_bordered(bool): are the boundaries/ uncertain regions already supplied in the prediction set for watershed segmentation. Default: False
        
    Returns:
        markers_set (list): List of markers obtained from the watershed segmentation for each image, each represented as a numpy array.
        properties_set(list): List of DataFrames for each image, each containing geometric properties.
        polygon_set (list): List of polygons for each image, each represented as a numpy array.
        
        
        
    '''
    
    markers_set=[]
    properties_set=[]
    polygon_set=[]
    
    
    for pred,base in zip(preds,images_base):
        if not is_bordered:
            bordered_img=make_borders(pred,erode=False,dilate=False)

        markers=watershed_segmentation(base,bordered_img)
        plt.show()
        
        markers_set.append(markers)
        df=region_properties(base,markers)

        properties_set.append(region_properties(base,markers))
        polygon_set.append(marker_to_polygon(markers,visualize=False))
    return markers_set, properties_set, polygon_set
            
def poly_to_coco(polygons_all,img_annots,category_id=1,start_test_id=1):
    """
    Converts polygons to COCO annotation format.

    Args:
      polygons (list): List of polygons, each represented as a numpy array.
      image_id (int): ID of the image.
      category_id (int): ID of the category.

    Returns:
      coco_annotation (dict): Dictionary in COCO annotation format.
    """

    coco_annotation = {
        "licenses":[{"name":"","id":0,"url":""}],#liscences of Data -> to define wheter open or not (as ours is not)
        "info":{"contributor":"","date_created":"","description":"","url":"","version":"","year":""},
        "categories": [
            {
                "id": category_id,
                "name": "porosity"  
            }
        ],
        "images":img_annots,
        "annotations": []
    }
    '''
    Polygons_all
    |_ Polygons of each Image
        |_ Polygons for each object
    
    '''
    idx=0
    for test_idx, polygons_of_image in enumerate(polygons_all):
        for polygon in polygons_of_image:
            # Flatten the polygon points into a single list
            segmentation = polygon.flatten().tolist()
            if len(segmentation)<6:
                continue

            # Create a bounding box from the polygon
            x, y, w, h = cv2.boundingRect(polygon)

            annotation = {
                "id": idx + 1,
                "image_id": test_idx+start_test_id,
                "category_id": category_id,
                "segmentation": [segmentation],
                "area": w * h,  # area of the bounding box
                "bbox": [x, y, w, h],
                "iscrowd": 1,
                'attributes': {'occluded': False}

            }

            coco_annotation["annotations"].append(annotation)
            idx+=1

    return coco_annotation
        
                
            
        

